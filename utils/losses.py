import torch
import torch.nn as nn
import torch.nn.functional as F
import piq  # SSIM and PSNR


def perceptual_quality_loss(output, target, alpha=1.0, beta=1.0, gamma=1.0):
    """
    Computes a weighted combination of L1, SSIM, and PSNR losses.

    Parameters:
        output (Tensor): Generated image.
        target (Tensor): Ground truth image.
        alpha (float): Weight for L1 loss.
        beta (float): Weight for SSIM loss.
        gamma (float): Weight for PSNR loss.

    Returns:
        Tensor: Weighted combined loss.
    """
    # L1 Loss (Mean Absolute Error)
    l1_loss = F.l1_loss(output, target)

    # SSIM Loss
    ssim_loss = 1 - piq.ssim(output, target, data_range=1.0)

    # PSNR Loss (lower PSNR corresponds to higher loss)
    psnr_value = piq.psnr(output, target, data_range=1.0)
    psnr_loss = -torch.log(psnr_value + 1e-7)  # Log transform for stability

    # Weighted sum of losses
    combined_loss = (alpha * l1_loss) + (beta * ssim_loss) + (gamma * psnr_loss)

    return combined_loss


def adversarial_loss(predictions, labels):
    """
    Computes the Binary Cross-Entropy loss for adversarial training.

    Parameters:
        predictions (Tensor): Predictions from the discriminator.
        labels (Tensor): True labels for real or fake images.

    Returns:
        Tensor: Binary Cross-Entropy loss.
    """
    bce_loss = nn.BCELoss()
    loss = bce_loss(predictions, labels)
    return loss


import torch
import torch.nn.functional as F
import piq  # For SSIM and PSNR


def perceptual_adversarial_loss(
    real_images,
    generated_images,
    real_preds,
    fake_preds,
    alpha=1.0,
    beta=1.0,
    gamma=1.0,
    delta=1.0,
):
    """
    Combines adversarial loss with perceptual losses (L1, SSIM, PSNR) for MRI super-resolution tasks.

    Parameters:
        real_images (Tensor): Ground truth high-resolution images.
        generated_images (Tensor): High-resolution images generated by the generator.
        real_preds (Tensor): Discriminator's predictions on real images.
        fake_preds (Tensor): Discriminator's predictions on generated images.
        alpha (float): Weight for adversarial loss.
        beta (float): Weight for perceptual L1.
        gamma (float): Weight for SSIM loss.
        delta (float): Weight for PSNR loss.

    Returns:
        Tensor: Combined Perceptual Adversarial Loss.
    """
    # Adversarial Loss (BCE)
    adversarial_loss_real = F.binary_cross_entropy_with_logits(
        real_preds, torch.ones_like(real_preds)
    )
    adversarial_loss_fake = F.binary_cross_entropy_with_logits(
        fake_preds, torch.zeros_like(fake_preds)
    )
    adversarial_loss = (adversarial_loss_real + adversarial_loss_fake) / 2

    # Perceptual L1 Loss
    l1_loss = F.l1_loss(generated_images, real_images)

    # SSIM Loss (1 - SSIM)
    ssim_loss = 1 - piq.ssim(generated_images, real_images, data_range=1.0)

    # PSNR Loss
    psnr_value = piq.psnr(generated_images, real_images, data_range=1.0)
    psnr_loss = -torch.log(psnr_value + 1e-7)

    # Weighted sum of all losses
    combined_loss = (
        (alpha * adversarial_loss)
        + (beta * l1_loss)
        + (gamma * ssim_loss)
        + (delta * psnr_loss)
    )

    return combined_loss


def total_variation_loss(image):
    # Assuming image of shape [1, height, width]
    if len(image.shape) == 3:
        image = image.unsqueeze(0)

    # Calculate TV loss
    tv_loss = torch.sum(
        torch.abs(image[:, :, :, :-1] - image[:, :, :, 1:])
    ) + torch.sum(torch.abs(image[:, :, :-1, :] - image[:, :, 1:, :]))

    return tv_loss


def GDNLoss(generated_HR, true_LR, estimated_blur_kernel, lambda_tv):
    """
    Parameters:
    - generated_HR: The generated high-resolution image (torch.Tensor).
    - true_HR: The true high-resolution image for comparison (torch.Tensor).
    - estimated_blur_kernel: List of estimated blur kernel corresponding to the LR image (torch.Tensor).
    - lambda_tv: Weight for the total variation loss (float).

    Returns:
    - loss.item(): The combined loss after optimization step (float).
    """

    # HR Reconstruction loss (MSE between generated HR and true HR)
    # loss_hr = F.mse_loss(generated_HR, true_HR)

    # Blur Kernel Estimation loss
    loss_blur = F.mse_loss(true_LR, estimated_blur_kernel)

    # Total Variation Loss for edge preservation in HR reconstruction
    tv_loss = total_variation_loss(generated_HR)

    # Combined loss
    total_loss = loss_blur + lambda_tv * tv_loss

    return total_loss.item()
